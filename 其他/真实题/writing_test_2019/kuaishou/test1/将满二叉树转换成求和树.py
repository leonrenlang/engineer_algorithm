# 题目描述
# 给出满出二叉树的先序和中序，输出其求和树的中序(每个节点将包含原始树中的左子树和右子树的和，但不包含本身)


# ——————————————————————————
# 示例1
# 输入
# 10 -2 8 -4 6 7 5
# 8 -2 -4 10 7 6 5
# 输出
# 0 4 0 20 0 12 0

# 二叉树：
#                   10
#                /      \
#              -2        6
#            /   \      /  \
#           8    -4    7    5
#
# 求和树：
#                  20(4-2+12+6)
#                /      \
#            4(8-4)      12(7+5)
#             /   \      /  \
#           0      0    0    0
#
# 输入描述:
# 2行整数，第1行表示二叉树的前序遍历，第2行表示二叉树的中序遍历，以空格分割
# 输出描述:
# 1行整数，表示求和树的中序遍历，以空格分割


# 思想：
# - 对于满二叉树，任何序都可以还原出一棵树，由于输出要求中序，因此直接使用中序即可
# - 直觉上，这道题应该使用后序遍历，但是这样要保留两棵树（求和树仅保留左右子树和，不保留自身
# 信息），并且代码复杂
# - 先序遍历
# 由于树的存储形式是数组，因此可以很方便的遍历每个节点，并且每个节点的结果不依赖于子问题的结果
# f(n)问题，既将整棵树转换成求和树，先求根节点的值（sun(arr) - 根节点），然后将子树转换成求和树
# base case叶节点的值一定为0
def transfer(arr):
    def process(arr, L, R):
        if L == R:
            arr[L] = 0
            return
        mid = (L + R) // 2
        arr[mid] = sum(arr[L:R + 1]) - arr[mid]
        process(arr, L, mid - 1)
        process(arr, mid + 1, R)

    process(arr, 0, len(arr) - 1)


def main():
    tmp = input()  # 后序没用，用一个变量装着
    mid_order_arr = [int(item) for item in input().split()]
    transfer(mid_order_arr)
    print(' '.join([str(item) for item in mid_order_arr]))


if __name__ == '__main__':
    main()
