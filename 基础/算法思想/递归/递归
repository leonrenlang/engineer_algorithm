


递归的两个要素：
1. 假设子问题已经完成了，找到父问题与子问题的关系
    - 如果每个父问题对应一个子问题，则程序会经过父问题函数两次如果每个父
    问题对应两个子问题，则程序会经过父问题函数三次（比如说树型结构）

2. base case


** 递归是另一种编程思想
-第一位程序员是拜伦女儿，那个时候的编程的模型是，我知道某些问题怎么计算
只是让计算机代替我来计算。
-图灵之后，引入了一种新的编程方法，我不知怎么算，但是我知道怎么试。
-P问题，多项式时间，我知道怎么算，让计算机帮我算就好了
    工程中的代码都是我严格知道怎么算的
-NP问题，我不知道怎么算，但是我知道怎么尝试
    # 图灵引入了，“我不知道怎么算”，但是我知道怎么试
    # 递归就是尝试
    # 递归代表尝试


动态规划：
动态规划就是为了优化暴力尝试
1. 从暴力递归中来
2. 将每一个子问题的解记录下来，避免重复计算
3. 将暴力递归的过程，抽象成了状态表达
4. 并且存在化简状态表达，使其更加简洁的可能

对于没有见过的动态规划问题：
- 首先用暴力版本递归方法
- 然后再改动态规划
    - 有些问题没法改动态规划（如汉诺塔问题），因为没有重复计算
    - 存在重复状态，无后效性（并且这个重复状态与到达它的路径无关，参考matrix_quickest_path),则可以改动态规划
- 改动态规划
    - base case成了初始值
    - 其他值要利用暴力递归中，大问题转小问题的规则求得。